# 좀 더 친절한 설명 — 왜 dp[i] = (조건1? dp[i-1] : 0) + (조건2? dp[i-2] : 0) 인가?
#
# 먼저 핵심 아이디어부터 아주 간단하게 말하면:
#
# 길이 i인 접두사(처음부터 i번째 문자까지)를 해석하는 모든 방법은 마지막에 어떤 '덩어리'로 끝나는가로 나눌 수 있다.
# 마지막 덩어리가 1자리이면 dp[i-1]에서 온 경우들, 2자리이면 dp[i-2]에서 온 경우들이다.
# 따라서 가능한(유효한) 덩어리들에 해당하는 이전 경우의 수를 더하면 전체 경우의 수가 된다.
#
# 이제 위 문장을 아주 차근차근 풀어볼게.
#
# 1) 상태의 정의
#
# dp[i]를 이렇게 정의하자:
#
# 문자열 s의 처음 i글자(즉 s[0..i-1])를 해석하는 서로 다른 방법의 수 = dp[i].
#
# 특히 dp[0] = 1으로 둔다 (빈 문자열을 해석하는 방법은 1가지 — 아무것도 선택하지 않는 방법).
# 이 dp[0] = 1이 나중에 dp[1]이나 dp[2]를 계산할 때 기반이 된다.
#
# 2) 마지막 덩어리(끝나는 방식)로 나누기
#
# 길이 i의 문자열을 해석하는 모든 경우를 생각하자. 맨 끝(오른쪽 끝) 이 어떻게 끝나는지를 보면 둘로 나뉜다:
#
# 마지막 한 자리만으로 끝난다 (예: ... | x)
#
# 이 경우, 마지막 한 자리(s[i-1])가 0이 아니어야(= 단독으로 유효) 한다.
#
# 그리고 앞의 i-1글자(s[0..i-2])는 어떤 방식으로든 해석되어 있어야 한다.
#
# 앞 i-1글자를 해석하는 모든 경우의 수가 dp[i-1] 이므로, 마지막이 한 자리인 경우의 수 = dp[i-1].
#
# 마지막 두 자리로 끝난다 (예: ... | yz, 즉 s[i-2:i])
#
# 이 경우, s[i-2:i]가 10 이상 26 이하의 유효한 숫자여야 한다.
#
# 그리고 앞의 i-2글자(s[0..i-3])는 어떤 방식으로든 해석되어 있어야 한다.
#
# 앞 i-2글자를 해석하는 경우의 수 = dp[i-2] 이므로, 마지막이 두 자리인 경우의 수 = dp[i-2].
#
# 두 경우(마지막이 1자리인 경우 vs 2자리인 경우)는 서로 겹치지 않는(disjoint) 경우의 수다. 따라서 전체 경우의 수는 둘을 더하면 된다.
#
# 결국
#
# dp[i] = (마지막 한 자리 유효하면 dp[i-1] 더하기) + (마지막 두 자리 유효하면 dp[i-2] 더하기)
#
#
# 가 된다.
#
# 3) 예제로 완전하게 따라가기 — s = "226" (정답 3)
#
# 가능한 해석을 직접 적어보면:
#
# 2 | 2 | 6 → B B F
#
# 22 | 6 → V F
#
# 2 | 26 → B Z
# 총 3가지.
#
# 이걸 dp로 계산하면:
#
# dp[0] = 1 (빈 문자열)
#
# i=1 ("2")
#
# 마지막 한 자리 '2'는 유효 → dp[1] += dp[0] = 1
#
# 마지막 두 자리는 없음.
# => dp[1] = 1
#
# i=2 ("22")
#
# 마지막 한 자리 '2' 유효 → dp[2] += dp[1] = 1
#
# 마지막 두 자리 "22" (10~26 사이) 유효 → dp[2] += dp[0] = 1
# => dp[2] = 2
#
# i=3 ("226")
#
# 마지막 한 자리 '6' 유효 → dp[3] += dp[2] = 2 (이 두 가지에서 각각 '6'을 붙인 경우)
#
# 마지막 두 자리 "26" 유효 → dp[3] += dp[1] = 1 (앞의 "2"에 "26"을 붙인 경우)
# => dp[3] = 3
#
# 여기서 직관 포인트: dp[2] = 2인 이유는 "22"까지의 해석이 두 가지였고, i=3에서 그 각각에 '6'을 단독으로 붙이는 경우가 2가지가 바로 dp[2]에 해당한다. 그리고 "26"을 하나의 문자로 해석하는 경우는 dp[1]에서 온다.
#
# 4) 0 처리는 왜 특별한가?
#
# 0은 단독으로 해석할 수 없다. 즉 '0'이 마지막 문자라면 단독 한 자리 선택(=dp[i-1])은 불가능하다. 단, '10'이나 '20' 같이 앞 숫자와 함께 두 자리로 보면 유효하므로 그 때는 dp[i-2]로 이어질 수 있다.
#
# 예: s = "100"
#
# dp0 = 1
#
# i=1: '1' → dp1 = 1
#
# i=2: '0' → 단독 불가, 두자리 "10"은 유효 → dp2 = dp0 = 1
#
# i=3: '0' → 단독 불가, 두자리 "00" 은 유효 X → dp3 = 0 → 전체 불가능
#
# 즉 0 있으면 항상 두자리와 함께 유효한지(10 또는 20인지) 확인해야 한다.
#
# 5) 수학적 보증(간단한 귀납법 생각)
#
# 길이 0일 때(dp[0]) 옳음.
#
# 길이 i일 때의 모든 해석은 "끝이 1자리인 경우"와 "끝이 2자리인 경우"로 정확히 나뉨(겹치지 않음).
#
# 끝이 1자리면 앞 i-1 길이의 모든 해석에 그 한 자를 붙이면 되고(그 수 = dp[i-1]), 끝이 2자리면 앞 i-2 길이의 모든 해석에 그 두 자를 붙이면 된다(그 수 = dp[i-2]).
#
# 따라서 점화식이 성립하고, 귀납적으로 전체 문자열 길이까지 적용 가능.
#
# 6) 구현(코드) — 한 번 더 (주석 포함)
s = input().strip()
n = len(s)

# 불가능한 경우(첫 글자가 0이면)
if n == 0 or s[0] == '0':
    print(0)
    exit()

dp = [0] * (n+1)
dp[0] = 1   # 빈 문자열 1가지
dp[1] = 1   # 첫 글자가 0이 아니면 1가지

for i in range(2, n+1):
    # 한 자리(마지막 문자) 확인
    if s[i-1] != '0':
        dp[i] += dp[i-1]

    # 두 자리(마지막 두 문자) 확인
    two = int(s[i-2:i])
    if 10 <= two <= 26:
        dp[i] += dp[i-2]

print(dp[n])